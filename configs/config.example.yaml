# KProxy Configuration Example

server:
  # DNS server (primary entry point for clients)
  dns_port: 53
  dns_enable_udp: true
  dns_enable_tcp: true

  # Proxy ports
  http_port: 80
  https_port: 443

  # Server name for client setup (certificate download, etc.)
  # This domain is always intercepted and allowed for all devices
  # HTTP requests to this domain are redirected to HTTPS
  # HTTPS requests serve the setup page and root certificate download
  name: "local.kproxy"

  # Metrics (Prometheus endpoint - replaces admin UI)
  metrics_port: 9090

  # Bind address (0.0.0.0 for all interfaces)
  bind_address: "0.0.0.0"

dns:
  # Upstream DNS servers for bypass/forwarded queries
  upstream_servers:
    - "8.8.8.8:53"
    - "1.1.1.1:53"

  # TTL settings
  intercept_ttl: 60       # TTL for intercepted domains (low for quick config changes)
  bypass_ttl_cap: 300     # Max TTL for bypassed domains (0 = no cap, use upstream)
  block_ttl: 60           # TTL for blocked domains

  # Query timeout
  upstream_timeout: "5s"

  # Global bypass domains (always bypass, never intercept)
  global_bypass:
    - "ocsp.*.com"        # Certificate validation
    - "crl.*.com"
    - "*.ocsp.*"
    - "time.*.com"        # NTP-related
    - "time.*.gov"

dhcp:
  # Enable/disable DHCP server for netboot support
  enabled: false

  # DHCP server port and bind address
  port: 67
  bind_address: "0.0.0.0"

  # DHCP server settings (auto-detected if not specified)
  # server_ip: "192.168.1.1"       # DHCP server identifier (auto-detected from network interface)
  # subnet_mask: "255.255.255.0"   # Network subnet mask (auto-detected from network interface)
  # gateway: "192.168.1.1"         # Default gateway for clients (auto-detected, uses server IP)

  # DNS servers to advertise to clients (empty = use server_ip as DNS)
  dns_servers: []

  # IP address pool for dynamic allocation (REQUIRED - must be configured manually)
  range_start: "192.168.1.100"
  range_end: "192.168.1.200"

  # Lease duration
  lease_time: "24h"

  # PXE/Network boot settings (for diskless/kiosk systems)
  # For BIOS PXE boot (legacy):
  boot_filename: "pxelinux.0"               # TFTP boot file
  boot_server_name: "kproxy.home.local"     # Boot server hostname
  tftp_ip: "192.168.1.1"                    # TFTP server IP

  # For UEFI HTTP boot (modern, recommended):
  boot_uri: "http://boot.netboot.xyz/ipxe/netboot.xyz.efi"  # HTTP boot URI
  # Examples:
  #   - netboot.xyz: "http://boot.netboot.xyz/ipxe/netboot.xyz.efi"
  #   - Custom iPXE: "http://192.168.1.1:8080/boot/ipxe.efi"
  #   - Local image: "http://192.168.1.1:8080/boot/kiosk.iso"

tls:
  # CA certificate and key paths
  ca_cert: "/etc/kproxy/ca/root-ca.crt"
  ca_key: "/etc/kproxy/ca/root-ca.key"

  # Intermediate CA (for signing)
  intermediate_cert: "/etc/kproxy/ca/intermediate-ca.crt"
  intermediate_key: "/etc/kproxy/ca/intermediate-ca.key"

  # Certificate cache settings
  cert_cache_size: 1000
  cert_cache_ttl: "24h"
  cert_validity: "24h"

  # Let's Encrypt integration (OPTIONAL - for trusted certificates on server.name)
  # By default, certificates are generated on-the-fly using the internal CA
  # Enable this to use Let's Encrypt for a publicly trusted certificate on server.name
  #
  # Benefits:
  # - Eliminates browser security warnings for setup page
  # - No need to install/trust custom CA certificate
  # - Automatic certificate renewal (requires re-running on expiry)
  #
  # Requirements:
  # - server.name must be a publicly resolvable domain you control
  # - DNS provider API credentials for ACME DNS-01 challenge
  # - Server runs on startup to obtain certificate before serving traffic
  #
  # Process on startup (when use_letsencrypt: true):
  # 1. Creates ACME account with Let's Encrypt
  # 2. Initiates DNS-01 challenge for domain ownership verification
  # 3. Creates TXT record via DNS provider API: _acme-challenge.{domain}
  # 4. Let's Encrypt validates DNS record
  # 5. Issues certificate and saves to lego_cert_path/lego_key_path
  # 6. Server continues normal operation
  #
  # All steps are logged with structured logging (see logs for progress)
  use_letsencrypt: false

  # lego_email: "admin@example.com"                    # Email for Let's Encrypt account (required)
  # lego_dns_provider: "cloudflare"                    # DNS provider name (required)

  # DNS provider credentials must be provided via environment variables
  # When using systemd, create /etc/sysconfig/kproxy with provider-specific variables:
  #
  # Cloudflare example (/etc/sysconfig/kproxy):
  #   CLOUDFLARE_EMAIL=admin@example.com
  #   CLOUDFLARE_API_KEY=your-global-api-key
  #   # OR use API token (recommended):
  #   # CLOUDFLARE_DNS_API_TOKEN=your-api-token
  #
  # Route53 example:
  #   AWS_ACCESS_KEY_ID=your-access-key
  #   AWS_SECRET_ACCESS_KEY=your-secret-key
  #   AWS_REGION=us-east-1
  #
  # DigitalOcean example:
  #   DO_AUTH_TOKEN=your-digitalocean-token
  #
  # Google Cloud DNS example:
  #   GCE_PROJECT=your-project-id
  #   GCE_SERVICE_ACCOUNT_FILE=/path/to/service-account.json
  #
  # See https://go-acme.github.io/lego/dns/ for full list of supported providers

  # lego_cert_path: "/etc/kproxy/certs/letsencrypt.crt"  # Where to save certificate
  # lego_key_path: "/etc/kproxy/certs/letsencrypt.key"   # Where to save private key

  # ACME directory URL (defaults to Let's Encrypt production)
  # lego_ca_dir_url: "https://acme-v02.api.letsencrypt.org/directory"
  #
  # For testing, use Let's Encrypt staging (higher rate limits, untrusted certs):
  # lego_ca_dir_url: "https://acme-staging-v02.api.letsencrypt.org/directory"

storage:
  # Storage backend type (only Redis is supported)
  type: "redis"

  # Redis settings
  redis:
    host: "localhost"
    port: 6379
    password: ""
    db: 0

    # Connection pool
    pool_size: 10
    min_idle_conns: 5

    # Timeouts
    dial_timeout: "5s"
    read_timeout: "3s"
    write_timeout: "3s"

logging:
  level: "info"  # debug, info, warn, error
  format: "json" # json, text

policy:
  # OPA policy configuration
  opa_policy_source: "filesystem"  # "filesystem" or "remote"
  opa_policy_dir: "/etc/kproxy/policies"  # Path to Rego policy files

  # For remote policy loading (alternative to filesystem):
  # opa_policy_urls:
  #   - "https://policy-server.example.com/policies/config.rego"
  #   - "https://policy-server.example.com/policies/device.rego"
  #   - "https://policy-server.example.com/policies/dns.rego"
  #   - "https://policy-server.example.com/policies/proxy.rego"
  #   - "https://policy-server.example.com/policies/helpers.rego"
  # opa_http_timeout: "30s"
  # opa_http_retries: 3

  # Default action for unknown devices
  default_action: "block"  # or "allow"

  # Default action for devices without matching rules
  default_allow: false

  # Device identification
  use_mac_address: true
  arp_cache_ttl: "5m"

usage_tracking:
  # Inactivity threshold for session tracking
  inactivity_timeout: "2m"

  # Minimum session duration to count
  min_session_duration: "10s"

  # Daily reset time (local timezone)
  daily_reset_time: "00:00"

response_modification:
  # Enable/disable timer injection
  enabled: true

  # Sites where injection is disabled
  disabled_hosts:
    - "*.bank.com"
    - "secure.*"

  # Content types to modify
  allowed_content_types:
    - "text/html"
